\documentclass[12pt,a4paper,final]{article}
\usepackage[utf8x]{inputenc}
\usepackage{ucs}
\usepackage[francais]{babel}
\usepackage[T1]{fontenc}
\usepackage{makeidx}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{hyperref}

\author{François \textsc{Hallereau} \\ Benjamin \textsc{Sientzoff}}
\title{Dictionnaire}

\makeindex

\begin{document}

\maketitle

\vspace{5cm}

\tableofcontents

\newpage

\section*{Introduction}
\addcontentsline{toc}{section}{\protect\numberline{}Introduction}
\paragraph{}{
Ce projet consiste à implémenter un dictionnaire (structure de données non ordonnée avec unicité). Cette implémentation a été réalisé de deux manières différentes. 

L'une utilise une table de hachage dans laquelle on stocke les mots. L'autre est un arbre où sont stocké un à un les caractères des mots à sauvegarder.

Le projet devra aussi contenir un code permettant de tester le bon fonctionnement des deux implémentations.

Pour compiler notre projet, la commande suivante est à utiliser :
\begin{verbatim}
 $ g++ -std=c++0x src/application.cpp application
\end{verbatim}

Puis pour l'exécution :
\begin{verbatim}
 $ ./src/application lenomdufichieralire
\end{verbatim}
}


\newpage

\section{Le \emph{dictionhache}}

		\begin{figure}[h]
			\hspace{-1.8cm}
			\input{class_hashtable.tex}
			\caption{Diagramme UML de classes pour le dictionnaire utilisant la \emph{Hashtable}.}
			\label{hashtable_uml}
		\end{figure}
		
	\paragraph{}{Cette version reprend la table de hachage du précédent projet tout en précisant les types de données qui sont ici : une chaîne de caractères pour la clé et un entier pour la valeur associée au mot. Ce qui permet de stocker la fréquence du mot en question. \\
Pour cette implémentation, les fonctions d'ajout et de modification reprennent les fonctions déjà existantes de la table de hachage. De plus une documentation est fournit au format PDF.}

	\paragraph{calcul des}{La fonction qui renvoie les dix mots les plus fréquents tri les mots de la table de hachage puis récupère les dix premiers éléments.}
	
	
\newpage 

\section{L'\emph{Arbramots}}

	\paragraph{}{
Le dictionnaire utilise la version de l'arbre implémenté dans la classe \textit{TreeString}.
Les fonctions d'ajout et de modification sont construite de la même manière puisque l'arbre gère nativement la modification de la valeur associée au mot.
La fonction \textit{valeurAssociee} fonctionne de la manière suivante : elle récupère tous les couples $<mot,occurences>$ contenu dans l'arbre puis renvoie la valeur associée du mot passé en paramètre.

Lors des tests, nous avons put remarquer que le temps d’exécution était nettement plus supérieur comparé à la version utilisant la table de hachage. 

Et pour cause, la fonction contientMot() de l'arbre utilise plus de ressource que celle de la table de hachage. De plus, l'arbre a été conçu pour qu'il n'y est pas besoin d'utiliser cette fonction à chaque ajout. 

On aurait donc très bien put n'utiliser que la fonction \textit{ajouterMot} même dans le cas ou le mot est déjà présent. Mais nous avons décider de garder les fonctions \textit{ajouterMot} et \textit{associerMot} dans un soucis du respect du cahier des charges.

Pour la fonction qui récupère les 10 mots les plus fréquents, elle est semblable à celle de la table de hachage. La seule différence étant la fonctions qui permet de récupérer tous les mots contenus dans la structure.
}
\newpage
  
\section*{Conclusion}
\paragraph{}{
Dans ce projet, on remarque que la table de hachage à un temps d'exécution inférieur à celui de l'arbre. en effet la table de hachage manipule directement des mots or l'arbre utilise des caractères qui nécessite d'être concaténé pour former une chaine. 
}
\addcontentsline{toc}{section}{\protect\numberline{}Conclusion}


\end{document}
